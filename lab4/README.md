# Отчет по выполнению работы — задача пошагового управления инвестиционным портфелем  
Преображенский Артемий Евгеньевич, поток 1.1

[Подкаст](https://drive.google.com/file/d/1Sw64ecPmC5jnwXlbMSAz1TCTBNIllPqE/view?usp=sharing)


---

## 1) Цель работы и постановка задачи
Цель — спланировать поэтапные покупки/продажи двух типов ценных бумаг и депозитов, чтобы максимизировать ожидаемую итоговую стоимость портфеля за три этапа при заданных вероятностях рыночных сценариев. Учитываются комиссии, минимальные объёмы и ограничение по свободным средствам.

Исходные данные
- Начальное состояние: ЦБ1=100, ЦБ2=800, Деп.=400, cash=600, итого 1900 д.е.
- Шаги управления: STEP = {cb1:25, cb2:200, dep:100}
- Минимумы: MINV = {cb1:30, cb2:150, dep:100}
- Комиссии: FEE = {cb1:0.04, cb2:0.07, dep:0.05}
- Три этапа; на каждом — три сценария (благопр., нейтр., негатив.) с заданными вероятностями и коэффициентами (см. STAGES в коде).

Ограничения: нельзя брать кредит (затраты на покупку с учётом комиссии ≤ cash), нельзя опустить активы ниже MINV, cash ≥ 0.

---

## 2) Общая математическая формулировка (DP)
Пусть s_k = (cb1, cb2, dep, cash) — состояние на шаге k. Управление u_k = (Δcb1, Δcb2, Δdep) — целые числа (число пакетов).  
Функция перехода f(s_k, u_k, w_k) — применение управления (минусы/плюсы пакетов с учётом комиссий → обновлённый cash и активы) и затем влияние рыночного сценария w_k (умножение активов на соответствующие коэффициенты; cash не меняется от рынка).  
Цель: максимизировать ожидаемую итоговую стоимость портфеля after last stage.

---

## 3) Рекуррентное соотношение Беллмана 

Рекуррентное соотношение Беллмана:

F_k(s) = max_{u ∈ U(s)} E_w [ F_{k+1}( f(s, u, w) ) ]

Граничное условие:
F_N(s) = total_value(s) = cb1 + cb2 + dep + cash

Обратный проход:
- Вычисляем F_k(s) для всех релевантных состояний s от k = N-1 до 0
- Используем мемоизацию для ускорения вычислений

Прямой проход:
- Из начального состояния выбираем оптимальные действия u_k, найденные на обратном проходе
- Формируем ожидаемое состояние портфеля после каждого u_k, учитывая вероятности рыночных сценариев (критерий Байеса)

---

## 4) Обозначения, постановка и рекуррентное соотношение конкретно для задачи
- s = { "cb1", "cb2", "dep", "cash" }  
- u = { "cb1": d1, "cb2": d2, "dep": dd } (целые пакеты)  
- Стоимость операции (учёт комиссии): для каждой позиции k вычисляем c = d * STEP[k]; при c>0 (покупка) умножаем на (1+FEE[k]), при c<0 (продажа) — на (1−FEE[k]). Сумма c — расход/выручка, применяется к cash: cash' = max(0, cash − sum_c). (В коде продажи считаются с уменьшением выручки через (1−fee).)  
- Ограничения: cb1' ≥ MINV["cb1"], cb2' ≥ MINV["cb2"], dep' ≥ MINV["dep"], cost ≤ cash.  
- Рекуррент: то же, что в секции 3, конкретно реализовано в методе `bellman(k, s)`.

---

## 5) Псевдокод
```
Алгоритм ДП для максимизации стоимости портфеля:

Вход:
  T — количество этапов
  A[t] — множество допустимых аллокаций на этапе t
  f(x, a) — функция перехода портфеля: новое состояние
  V0 — начальное состояние

Определения:
  V[t][s] — максимальная будущая стоимость портфеля,
            если в момент t мы находимся в состоянии s.
  Bellman(t, s):
      если t = T:
          вернуть Value(s)
      иначе:
          максимум по всем a ∈ A[t]:
              Bellman(t+1, f(s, a))

Основной алгоритм:
  Создать хэш-таблицу memo
  Функция Solve(t, s):
      если (t, s) в memo:
          вернуть memo[(t, s)]
      если t = T:
          memo[(t, s)] = Value(s)
          вернуть Value(s)
      best = -∞
      для каждого действия a из A[t]:
          next_s = f(s, a)
          val = Solve(t+1, next_s)
          если val > best:
              best = val
      memo[(t, s)] = best
      вернуть best

Запуск:
  Answer = Solve(1, начальное состояние)

Вывод:
  Максимальная конечная стоимость = Answer
```

## 6) Диаграмма классов
В коде применена простая процедурно-объектная структура:

- `InvestmentPlanner` — основной класс, содержит:
  - `cache` — словарь для мемоизации;
  - `total(s)` — возвращает суммарную стоимость состояния;
  - `apply_action(s, a)` — применяет действие с учётом шагов и комиссий, возвращает новое состояние;
  - `apply_sit(s, k, idx)` — применяет один сценарий рынка (коэффициенты из STAGES) к состоянию;
  - `actions(s)` — генерация допустимых действий (диапазон шагов от −2 до 2 с проверкой MINV и доступного cash);
  - `bellman(k, s)` — рекурсивный DP с кешем;
  - `solve()` — прямой проход, собирает путь оптимальных действий.
- Модуль `data` хранит константы: FEE, INIT, MINV, STAGES, STEP.

---

## 7) Демонстрационные примеры 

![](assets/1.png)

---

## 8) Заключение
Сделано:
- формализована задача управления портфелем в терминах DP;
- выписано и реализовано рекуррентное соотношение Беллмана;
- реализован класс `InvestmentPlanner` с мемоизацией, генерацией действий, учётом комиссий и ограничений;
- получена оптимальная стратегия и численный результат (см. раздел 7).

Чему научился:
- как переводить экономическую задачу в DP-модель;



